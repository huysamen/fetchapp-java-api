FetchApp API Implementation (Java)
==================================

This library provides a Java implementation library to communicate with the FetchApp REST (version 2) API to manage
FetchApp accounts. In its current form, it provides both synchronous and asynchronous communication using the Jetty
client.


###Synchronous Usage

To use synchronous communication (i.e. your execution thread will block while a call to FetchApp is made), use the
following (The "apiKey" is your application key you specified during the creation of your FetchApp account, and the
"apiKey" is the API key generated by FetchApp, viewable in your account settings):

    FetchApi api = new JettySyncFetchApi("apiKey", "appToken");
    
This will create a Jetty client with sensible default values for number of connections and execution threads. You can
override these values by using the overloaded constructor:

    FetchApi api = new JettySyncFetchApi("apiKey", "appToken", maxConnectionsPerAddress, connectionQueueSize, connectionTimeout);
    
Once you have successfully created your JettySyncFechApi object, you can continue to interact with their API. The
following methods are available, and implement the full range of the functionality the FetchApp API provides:

    public Account getAccountInformation();
    public Message requestNewApiToken();
    public Files getFiles();
    public Downloads getDownloads();
    public Orders getOrders();
    public Orders getOpenOrders();
    public Orders getExpiredOrders();
    public Order getOrder(final String id);
    public Order createOrder(final OrderData order);
    public Order updateOrder(final OrderData order);
    public Message deleteOrder(final String id);
    public Downloads getOrderDownloads(final String id);
    public Message expireOrder(final String id);
    public Message sendOrderEmail(final String id, final boolean resetExpiration);
    public Message sendOrderEmail(final String id, final Date expirationDate);
    public OrderStats getOrderStatistics(final String id);
    public OrderItems getOrderItems(final String id);
    public OrderItem getOrderItem(final String orderId, final String id);
    public OrderItemFiles getOrderItemFiles(final String orderId, final String id);
    public Downloads getOrderItemDownloads(final String orderId, final String id);
    public Products getProducts();
    public Product getProduct(final String sku);
    public Product createProduct(final ProductData product);
    public Product updateProduct(final ProductData product);
    public Message deleteProduct(final String sku);
    public ProductStats getProductStatistics(final String sku);
    public Files getProductFiles(final String sku);
    public Downloads getProductDownloads(final String sku);
    
### Asynchronous Usage

The asynchronous communication implementation provides usage that is much less intrusive on your application flow,
and should be used if possible. The methods available are identical to those described above, with the exception
that all methods return a ListenableFuture (from the Google Guava library) with a generic type as described above.

This future object is returned immediatly, and as such your thread of execution can continue. Only on calling the
get() method on the future object will the thread block until either a value is set on the future (which will
happen when a response is received from FetchApp), or the timeout value you specify to the get method (if you so wish)
expires.

    FetchAsyncApi api = new JettyAsyncFetchApi("apiKey", "apiToken");
    
or

    FetchAsyncApi api = new JettyAsyncFetchApi("apiKey", "apiToken", maxConnectionsPerAddress, connectionQueueSize, connectionTimeout);
    
The use of the future objects are as follows:

    final ListenableFuture<Account> future = api.getAccountInformation();
    
    ...
    // other application code
    ...
    
    final Account account = future.get();
    
This will block the thread until a value is set on the future. It is possible to set a timeout value on the
future object as follows:

    final Account account = future.get(1000, TimeUnit.MILLISECONDS);
